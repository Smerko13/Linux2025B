#define CONF_FILE_PATH "/tmp/mtacrypt/mtacrypt.conf"
#define SUBSCRIPTION_PIPE_PATH "/tmp/mtacrypt/encrypter_pipe"
#define BROADCAST_PIPE_PATH "/tmp/mtacrypt/broadcast_pipe"
#define LOG_FILE_PATH "/var/log/encrypter.log"
#include "mta_crypt.h"
#include "mta_rand.h"
#include "crypt.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <stdbool.h>
#include <errno.h>
#include <dirent.h>
#include <syslog.h>
#include <time.h>

struct pass_data
{
    int* decrypter_arr;  // Array to store decrypter file descriptors
    int* decrypter_ids;  // Array to store decrypter IDs
    int arr_last_index;  // Last index of the decrypter arrays
    char* password; // The current password the encrypter is working with
    unsigned int length; // Length of the password
    char* key; // Key used for encryption
    unsigned int key_length; // Key length
    char* encrypted_password; // Encrypted password generated by the encrypter
    unsigned int encrypted_password_length; // Length of the encrypted password
    char* decrypter_guessed_password; // Buffer to hold guessed password from decrypters
};

void read_conf_file(struct pass_data *data);
void generate_password_and_key(struct pass_data *data);
void create_subscription_pipe();
void connect_new_decrypter(int decrypter_id, struct pass_data *data);
void create_broadcast_pipe();
void clear_pipe_library();
ssize_t read_full(int fd, void* buffer,size_t length);
ssize_t write_full(int fd, const void* buffer, size_t length);
void log_message(const char* message);
void init_logging();
void broadcast_new_password_to_all_decrypters(struct pass_data *data);

int main()
{
    init_logging(); // Initialize logging
    clear_pipe_library(); // Clear old pipes and files
    MTA_crypt_init(); // Initialize cryptography library
    struct pass_data data; // Struct used to hold current encrypter data
    read_conf_file(&data); // Read configuration file to get password length
    generate_password_and_key(&data); // Generate password and key based on the configuration file
    create_subscription_pipe(); // Create the subscription pipe for communication for receiving new decrypters
    create_broadcast_pipe(); // Create the broadcast pipe for sending new passwords
    int encrypter_fd = open(SUBSCRIPTION_PIPE_PATH, O_RDONLY); // Open the subscription pipe for reading
    if (encrypter_fd < 0) {
        char err_msg[256];
        sprintf(err_msg, "%ld [ENCRYPTER] [ERROR] Failed to open subscription pipe", time(NULL));
        log_message(err_msg);
        exit(1);
    }else{
        char log_msg[256];
        sprintf(log_msg, "Listening on %s\n", SUBSCRIPTION_PIPE_PATH);
        log_message(log_msg);
    }

    int decrypter_id = 0;
    if(read_full(encrypter_fd, &decrypter_id, sizeof(decrypter_id)) != sizeof(decrypter_id)) // Read the first decrypter ID
    {
        char err_msg[256];
        sprintf(err_msg, "%ld [ENCRYPTER] [ERROR] Failed to read decrypter ID from subscription pipe", time(NULL));
        log_message(err_msg);
        close(encrypter_fd);
        exit(1);
    }
    connect_new_decrypter(decrypter_id, &data); // Connect the first decrypter
    close(encrypter_fd); // Close the subscription pipe after reading the first decrypter ID
    encrypter_fd = open(SUBSCRIPTION_PIPE_PATH, O_RDONLY | O_NONBLOCK); // Reopen the subscription pipe for reading decrypter IDs in non blocking
    while(true)
    {
        ssize_t n = read(encrypter_fd, &decrypter_id, sizeof(decrypter_id)); // Read new decrypter ID
        if(n < 0)
        {
            if(errno == EAGAIN || errno == EWOULDBLOCK)
            {
                // No more decrypter IDs to read, continue to next iteration
                usleep(10000); // Sleep for 10ms to avoid busy waiting
                // Continue to check existing decrypters for guesses
            } else {
                char err_msg[256];
                sprintf(err_msg, "%ld [ENCRYPTER] [ERROR] Failed to read decrypter ID from subscription pipe", time(NULL));
                log_message(err_msg);
                close(encrypter_fd);
                exit(1);
            }
        }
        else if(n == sizeof(decrypter_id))
        {
            connect_new_decrypter(decrypter_id, &data); // Connect the new decrypter
        }
        
        for(int i = 0 ; i < data.arr_last_index; i++)
        {
            int decrypter_fd = data.decrypter_arr[i]; // Get the file descriptor for the decrypter
            
            // Use non-blocking read to check if decrypter has sent a guess
            fcntl(decrypter_fd, F_SETFL, O_NONBLOCK);
            ssize_t bytes_read = read(decrypter_fd, data.decrypter_guessed_password, data.length);
            
            if(bytes_read == data.length) // Successfully read a complete guess
            {
                data.decrypter_guessed_password[data.length] = '\0'; // Null-terminate the guessed password

                if (strcmp(data.decrypter_guessed_password, data.password) == 0) {
                    char log_msg[256];
                    sprintf(log_msg, "%ld [ENCRYPTER] [INFO] Password decrypted successfully by decrypter #%d", time(NULL), data.decrypter_ids[i]);
                    log_message(log_msg);
                    
                    // Generate a new password and broadcast to all decrypters
                    generate_password_and_key(&data);
                    broadcast_new_password_to_all_decrypters(&data);
                    break;
                }
            }
            else if(bytes_read < 0 && errno != EAGAIN && errno != EWOULDBLOCK)
            {
                // Error reading from this decrypter - might be disconnected
                char err_msg[256];
                sprintf(err_msg, "%ld [ENCRYPTER] [WARNING] Error reading from decrypter #%d", time(NULL), i);
                log_message(err_msg);
            }
        }
        
    }

    close(encrypter_fd);
    free(data.decrypter_arr);
    free(data.decrypter_ids);
    free(data.password);
    free(data.key);
    free(data.encrypted_password);

    return 0;
}

// Reads the configuration file to get the password length and initializes the data structure
void read_conf_file(struct pass_data *data)
{
    char log_msg[256];
    sprintf(log_msg, "Reading %s...", CONF_FILE_PATH);
    log_message(log_msg);

    FILE *conf_file = fopen(CONF_FILE_PATH, "r");
    if (!conf_file) {
        char err_msg[256];
        sprintf(err_msg, "%ld [ENCRYPTER] [ERROR] Failed to open configuration file", time(NULL));
        log_message(err_msg);
        exit(1);
    }

    fscanf(conf_file, "PASSWORD_LENGTH=%d", &data->length);
    fclose(conf_file);

    if (data->length <= 0 || data->length % 8 != 0) {
        char err_msg[256];
        sprintf(err_msg, "%ld [ENCRYPTER] [ERROR] Invalid password length specified in configuration file: %d\n", time(NULL), data->length);
        log_message(err_msg);
        exit(1);
    }

    data->key_length = data->length / 8; // Key length is 1/8th of password length
    sprintf(log_msg, "Password length set to %d\n", data->length);
    log_message(log_msg);
    data->decrypter_arr = malloc(sizeof(int)); // Allocate initial size for decrypter array
    data->decrypter_ids = malloc(sizeof(int)); // Allocate initial size for decrypter IDs array
    data->arr_last_index = 0; // Start with size 0
}

// Generates a random password and key, encrypts the password, and initializes the data structure
// Also allocates memory for the encrypted password and guessed password
void generate_password_and_key(struct pass_data *data)
{
    const char *charset = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    unsigned int charset_size  = strlen(charset);

    data->password = malloc(data->length + 1); // +1 for null terminator
    for(int i = 0 ; i < data->length; i++) {
        data->password[i] = charset[MTA_get_rand_char() % charset_size]; // Generate random index
    }
    data->password[data->length] = '\0'; // Null-terminate the password string

    data->key = malloc(data->key_length + 1); // Allocate memory for key
    for(int i = 0; i < data->key_length; i++) {
        data->key[i] = MTA_get_rand_char(); // Generate random byte for key
    }
    data->key[data->key_length] = '\0'; // Null-terminate the key string

    data->encrypted_password = malloc(data->length + 1); // Allocate memory for encrypted password
    data->decrypter_guessed_password = malloc(data->length + 1); // Allocate memory for guessed password
    MTA_encrypt(data->key, data->key_length, data->password, data->length, data->encrypted_password, &data->encrypted_password_length);
    data->encrypted_password[data->encrypted_password_length] = '\0'; // Null-terminate the encrypted password string
    char log_msg[1024];
    sprintf(log_msg, "%ld [ENCRYPTER] [INFO] New password generated: %s, key: %s, After encryption: %s\n", time(NULL), data->password, data->key, data->encrypted_password);
    log_message(log_msg);
}

// Create the subscription pipe for receiving new decrypters
void create_subscription_pipe()
{
    if(access(SUBSCRIPTION_PIPE_PATH, F_OK) == 0) {
        // Pipe already exists, remove it
        if (unlink(SUBSCRIPTION_PIPE_PATH) != 0) {
            char err_msg[256];
            sprintf(err_msg, "%ld [ENCRYPTER] [ERROR] Failed to remove existing subscription pipe", time(NULL));
            log_message(err_msg);
            exit(1);
        }
    }

    if (mkfifo(SUBSCRIPTION_PIPE_PATH, 0666) != 0) {
        char err_msg[256];
        sprintf(err_msg, "%ld [ENCRYPTER] [ERROR] Failed to create subscription pipe", time(NULL));
        log_message(err_msg);
        exit(1);
    }
}

// Creates the broadcast pipe for sending messages to all decrypters
void create_broadcast_pipe()
{
    if(access(BROADCAST_PIPE_PATH, F_OK) == 0) {
        // Pipe already exists, remove it
        if (unlink(BROADCAST_PIPE_PATH) != 0) {
            char err_msg[256];
            sprintf(err_msg, "%ld [ENCRYPTER] [ERROR] Failed to remove existing broadcast pipe", time(NULL));
            log_message(err_msg);
            exit(1);
        }
    }

    if (mkfifo(BROADCAST_PIPE_PATH, 0666) != 0) {
        char err_msg[256];
        sprintf(err_msg, "%ld [ENCRYPTER] [ERROR] Failed to create broadcast pipe", time(NULL));
        log_message(err_msg);
        exit(1);
    }
}

// Connects a new decrypter and sends the initial encrypted password
void connect_new_decrypter(int decrypter_id, struct pass_data *data)
{
    char log_msg[256];
    sprintf(log_msg, "%ld [ENCRYPTER] [INFO] Recieved connection request from decrypter id %d, fifo name /tmp/mtacrypt/decrypter_pipe_%d\n", time(NULL), decrypter_id, decrypter_id);
    log_message(log_msg);
    char decrypter_pipe_name[50];
    sprintf(decrypter_pipe_name, "/tmp/mtacrypt/decrypter_pipe_%d", decrypter_id);

    int decrypted_fd = open(decrypter_pipe_name, O_WRONLY);
    if (decrypted_fd < 0) {
        char err_msg[256];
        sprintf(err_msg, "%ld [ENCRYPTER] [ERROR] Failed to open decrypter pipe for writing", time(NULL));
        log_message(err_msg);
        exit(1);
    }

    if(write_full(decrypted_fd, &data->length, sizeof(data->length)) != sizeof(data->length)) // Write the encrypted password length
    {
        char err_msg[256];
        sprintf(err_msg, "%ld [ENCRYPTER] [ERROR] Failed to write password length to decrypter pipe", time(NULL));
        log_message(err_msg);
        close(decrypted_fd);
        exit(1);
    }
    if(write_full(decrypted_fd, &data->encrypted_password_length, sizeof(data->encrypted_password_length)) != sizeof(data->encrypted_password_length)) // Write the encrypted password length
    {
        char err_msg[256];
        sprintf(err_msg, "%ld [ENCRYPTER] [ERROR] Failed to write encrypted password length to decrypter pipe", time(NULL));
        log_message(err_msg);
        close(decrypted_fd);
        exit(1);
    }
    if(write_full(decrypted_fd, data->encrypted_password, data->encrypted_password_length) != data->encrypted_password_length) // Write the encrypted password
    {
        char err_msg[256];
        sprintf(err_msg, "%ld [ENCRYPTER] [ERROR] Failed to write encrypted password to decrypter pipe", time(NULL));
        log_message(err_msg);
        close(decrypted_fd);
        exit(1);
    }
    
    int* tmp = realloc(data->decrypter_arr,(data->arr_last_index + 1) * sizeof(int)); // Reallocate memory for the decrypter array
    int* tmp_ids = realloc(data->decrypter_ids,(data->arr_last_index + 1) * sizeof(int)); // Reallocate memory for the decrypter IDs array
    if(tmp == NULL || tmp_ids == NULL) {
        char err_msg[256];
        sprintf(err_msg, "%ld [ENCRYPTER] [ERROR] Failed to reallocate memory for decrypter arrays", time(NULL));
        log_message(err_msg);
        close(decrypted_fd);
        exit(1);
    }
    data->decrypter_arr = tmp; // Update the decrypter array pointer
    data->decrypter_ids = tmp_ids; // Update the decrypter IDs array pointer
    close(decrypted_fd); // Close the decrypter pipe after writing the encrypted password
    int read_fd= open(decrypter_pipe_name, O_RDONLY ); // Open the decrypter pipe for reading in non-blocking mode
    if (read_fd < 0) {
        char err_msg[256];
        sprintf(err_msg, "%ld [ENCRYPTER] [ERROR] Failed to open decrypter pipe for reading", time(NULL));
        log_message(err_msg);
        exit(1);
    }
    data->decrypter_arr[data->arr_last_index] = read_fd; // Add the new decrypter file descriptor to the array
    data->decrypter_ids[data->arr_last_index] = decrypter_id; // Store the decrypter ID
    data->arr_last_index++; // Increment the last index
}

// Clear the pipe library by removing all pipes and files except the configuration file
void clear_pipe_library()
{
    char log_msg[256];
    const char *path = "/tmp/mtacrypt";
    const char* file_to_keep = "mtacrypt.conf"; // File to keep
    DIR *dir = opendir(path);
    if (!dir) {
        sprintf(log_msg, "%ld [ENCRYPTER] [ERROR] Failed to open %s directory", time(NULL), path);
        log_message(log_msg);
        return;
    }

    struct dirent *entry;
    char full_path[1024];

    while((entry = readdir(dir)) != NULL)
    {
        if(strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue; // Skip current and parent directory entries
        if(strcmp(entry->d_name, file_to_keep) == 0)
            continue; // Skip the file we want to keep
        snprintf(full_path, sizeof(full_path), "%s/%s", path, entry->d_name);

        unlink(full_path); // Remove the file or pipe
    }

    closedir(dir);
}

ssize_t read_full(int fd, void* buffer,size_t length)
{
    size_t total_read = 0;
    while (total_read < length) {
        ssize_t bytes_read = read(fd, (char*)buffer + total_read, length - total_read);
        if (bytes_read < 0) {
            return -1; // Error occurred
        } 
        total_read += bytes_read;
    }
    return total_read; // Return the total number of bytes read
}

// Writes the full buffer to the file descriptor
ssize_t write_full(int fd, const void* buffer, size_t length)
{
    size_t total_written = 0;
    const char*p = buffer;
    while (total_written < length) {
        ssize_t bytes_written = write(fd, p + total_written, length - total_written);
        if (bytes_written < 0) {
            return -1; // Error occurred
        }
        total_written += bytes_written;
    }
    return total_written; // Return the total number of bytes written
}

// Initialize logging to syslog and log file
void init_logging()
{
    openlog("encrypter.out", LOG_PID | LOG_CONS, LOG_USER);
}

// Log a message to syslog and a log file
void log_message(const char* message)
{
    // Log to syslog
    syslog(LOG_INFO, "%s", message);
    
    // Also log to file
    FILE* log_file = fopen(LOG_FILE_PATH, "a");
    if (log_file) {
        fprintf(log_file, "%s\n", message);
        fclose(log_file);
    }
}

// Broadcasts the new password to all connected decrypters
// This function creates individual broadcast pipes for each decrypter to ensure reliable delivery
void broadcast_new_password_to_all_decrypters(struct pass_data *data)
{
    // Only attempt to broadcast if there are connected decrypters
    if (data->arr_last_index == 0) {
        return;
    }
    
    // Create individual broadcast pipes for each decrypter to ensure reliable delivery
    for(int i = 0; i < data->arr_last_index; i++) {
        char broadcast_pipe_name[100];
        sprintf(broadcast_pipe_name, "/tmp/mtacrypt/broadcast_pipe_%d", data->decrypter_ids[i]);
        
        // Create individual broadcast pipe for this decrypter
        if (mkfifo(broadcast_pipe_name, 0666) != 0) {
            if (errno != EEXIST) {
                continue;
            }
        }
        
        // Open the specific broadcast pipe for writing
        int broadcast_fd = open(broadcast_pipe_name, O_WRONLY | O_NONBLOCK);
        if (broadcast_fd >= 0) {
            // Send password data to this specific decrypter
            if (write_full(broadcast_fd, &data->length, sizeof(data->length)) == sizeof(data->length)) {
                if (write_full(broadcast_fd, &data->encrypted_password_length, sizeof(data->encrypted_password_length)) == sizeof(data->encrypted_password_length)) {
                    if (write_full(broadcast_fd, data->encrypted_password, data->encrypted_password_length) == data->encrypted_password_length) {
                        char log_msg[256];
                        sprintf(log_msg, "%ld [ENCRYPTER] [INFO] Sent new password to decrypter #%d via dedicated broadcast pipe", time(NULL), data->decrypter_ids[i]);
                        log_message(log_msg);
                    } else {
                        char log_msg[256];
                        sprintf(log_msg, "%ld [ENCRYPTER] [WARNING] Failed to send encrypted password data to decrypter #%d", time(NULL), data->decrypter_ids[i]);
                        log_message(log_msg);
                    }
                } else {
                    char log_msg[256];
                    sprintf(log_msg, "%ld [ENCRYPTER] [WARNING] Failed to send encrypted password length to decrypter #%d", time(NULL), data->decrypter_ids[i]);
                    log_message(log_msg);
                }
            } else {
                char log_msg[256];
                sprintf(log_msg, "%ld [ENCRYPTER] [WARNING] Failed to send password length to decrypter #%d", time(NULL), data->decrypter_ids[i]);
                log_message(log_msg);
            }
            close(broadcast_fd);
        } else {
            char log_msg[256];
            sprintf(log_msg, "%ld [ENCRYPTER] [WARNING] Failed to open broadcast pipe for decrypter #%d", time(NULL), data->decrypter_ids[i]);
            log_message(log_msg);
        }
    }
}